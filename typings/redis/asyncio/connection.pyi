"""
This type stub file was generated by pyright.
"""

import asyncio
import enum
import sys
import ssl
from abc import abstractmethod
from typing import Any, Callable, Iterable, List, Mapping, Optional, Protocol, Tuple, Type, TypeVar, TypedDict, Union
from ..utils import SSL_AVAILABLE, deprecated_args
from ssl import SSLContext, TLSVersion
from ..auth.token import TokenInterface
from ..event import EventDispatcher
from redis.asyncio.retry import Retry
from redis.credentials import CredentialProvider
from redis.typing import EncodableT
from redis.utils import HIREDIS_AVAILABLE
from .._parsers import BaseParser, Encoder, _AsyncHiredisParser, _AsyncRESP2Parser, _AsyncRESP3Parser

if SSL_AVAILABLE:
    ...
else:
    ssl = ...
    TLSVersion = ...
    SSLContext = ...
if sys.version_info >= (3, 11, 3):
    ...
else:
    ...
SYM_STAR = ...
SYM_DOLLAR = ...
SYM_CRLF = ...
SYM_LF = ...
SYM_EMPTY = ...
class _Sentinel(enum.Enum):
    sentinel = ...


SENTINEL = ...
DefaultParser: Type[Union[_AsyncRESP2Parser, _AsyncRESP3Parser, _AsyncHiredisParser]]
if HIREDIS_AVAILABLE:
    DefaultParser = ...
else:
    DefaultParser = ...
class ConnectCallbackProtocol(Protocol):
    def __call__(self, connection: AbstractConnection): # -> None:
        ...
    


class AsyncConnectCallbackProtocol(Protocol):
    async def __call__(self, connection: AbstractConnection): # -> None:
        ...
    


ConnectCallbackT = Union[ConnectCallbackProtocol, AsyncConnectCallbackProtocol]
class AbstractConnection:
    """Manages communication to and from a Redis server"""
    __slots__ = ...
    def __init__(self, *, db: Union[str, int] = ..., password: Optional[str] = ..., socket_timeout: Optional[float] = ..., socket_connect_timeout: Optional[float] = ..., retry_on_timeout: bool = ..., retry_on_error: Union[list, _Sentinel] = ..., encoding: str = ..., encoding_errors: str = ..., decode_responses: bool = ..., parser_class: Type[BaseParser] = ..., socket_read_size: int = ..., health_check_interval: float = ..., client_name: Optional[str] = ..., lib_name: Optional[str] = ..., lib_version: Optional[str] = ..., username: Optional[str] = ..., retry: Optional[Retry] = ..., redis_connect_func: Optional[ConnectCallbackT] = ..., encoder_class: Type[Encoder] = ..., credential_provider: Optional[CredentialProvider] = ..., protocol: Optional[int] = ..., event_dispatcher: Optional[EventDispatcher] = ...) -> None:
        ...
    
    def __del__(self, _warnings: Any = ...): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @abstractmethod
    def repr_pieces(self): # -> None:
        ...
    
    @property
    def is_connected(self): # -> bool:
        ...
    
    def register_connect_callback(self, callback): # -> None:
        """
        Register a callback to be called when the connection is established either
        initially or reconnected.  This allows listeners to issue commands that
        are ephemeral to the connection, for example pub/sub subscription or
        key tracking.  The callback must be a _method_ and will be kept as
        a weak reference.
        """
        ...
    
    def deregister_connect_callback(self, callback): # -> None:
        """
        De-register a previously registered callback.  It will no-longer receive
        notifications on connection events.  Calling this is not required when the
        listener goes away, since the callbacks are kept as weak methods.
        """
        ...
    
    def set_parser(self, parser_class: Type[BaseParser]) -> None:
        """
        Creates a new instance of parser_class with socket size:
        _socket_read_size and assigns it to the parser for the connection
        :param parser_class: The required parser class
        """
        ...
    
    async def connect(self): # -> None:
        """Connects to the Redis server if not already connected"""
        ...
    
    async def connect_check_health(self, check_health: bool = ..., retry_socket_connect: bool = ...): # -> None:
        ...
    
    def get_protocol(self): # -> int | None:
        ...
    
    async def on_connect(self) -> None:
        """Initialize the connection, authenticate and select a database"""
        ...
    
    async def on_connect_check_health(self, check_health: bool = ...) -> None:
        ...
    
    async def disconnect(self, nowait: bool = ...) -> None:
        """Disconnects from the Redis server"""
        ...
    
    async def check_health(self): # -> None:
        """Check the health of the connection with a PING/PONG"""
        ...
    
    async def send_packed_command(self, command: Union[bytes, str, Iterable[bytes]], check_health: bool = ...) -> None:
        ...
    
    async def send_command(self, *args: Any, **kwargs: Any) -> None:
        """Pack and send a command to the Redis server"""
        ...
    
    async def can_read_destructive(self):
        """Poll the socket to see if there's data that can be read."""
        ...
    
    async def read_response(self, disable_decoding: bool = ..., timeout: Optional[float] = ..., *, disconnect_on_error: bool = ..., push_request: Optional[bool] = ...): # -> None:
        """Read the response from a previously sent command"""
        ...
    
    def pack_command(self, *args: EncodableT) -> List[bytes]:
        """Pack a series of arguments into the Redis protocol"""
        ...
    
    def pack_commands(self, commands: Iterable[Iterable[EncodableT]]) -> List[bytes]:
        """Pack multiple commands into the Redis protocol"""
        ...
    
    async def process_invalidation_messages(self): # -> None:
        ...
    
    def set_re_auth_token(self, token: TokenInterface): # -> None:
        ...
    
    async def re_auth(self): # -> None:
        ...
    


class Connection(AbstractConnection):
    "Manages TCP communication to and from a Redis server"
    def __init__(self, *, host: str = ..., port: Union[str, int] = ..., socket_keepalive: bool = ..., socket_keepalive_options: Optional[Mapping[int, Union[int, bytes]]] = ..., socket_type: int = ..., **kwargs) -> None:
        ...
    
    def repr_pieces(self): # -> list[Any]:
        ...
    


class SSLConnection(Connection):
    """Manages SSL connections to and from the Redis server(s).
    This class extends the Connection class, adding SSL functionality, and making
    use of ssl.SSLContext (https://docs.python.org/3/library/ssl.html#ssl.SSLContext)
    """
    def __init__(self, ssl_keyfile: Optional[str] = ..., ssl_certfile: Optional[str] = ..., ssl_cert_reqs: Union[str, ssl.VerifyMode] = ..., ssl_ca_certs: Optional[str] = ..., ssl_ca_data: Optional[str] = ..., ssl_check_hostname: bool = ..., ssl_min_version: Optional[TLSVersion] = ..., ssl_ciphers: Optional[str] = ..., **kwargs) -> None:
        ...
    
    @property
    def keyfile(self): # -> str | None:
        ...
    
    @property
    def certfile(self): # -> str | None:
        ...
    
    @property
    def cert_reqs(self): # -> str | None:
        ...
    
    @property
    def ca_certs(self): # -> str | None:
        ...
    
    @property
    def ca_data(self): # -> str | None:
        ...
    
    @property
    def check_hostname(self): # -> bool:
        ...
    
    @property
    def min_version(self): # -> None:
        ...
    


class RedisSSLContext:
    __slots__ = ...
    def __init__(self, keyfile: Optional[str] = ..., certfile: Optional[str] = ..., cert_reqs: Optional[Union[str, ssl.VerifyMode]] = ..., ca_certs: Optional[str] = ..., ca_data: Optional[str] = ..., check_hostname: bool = ..., min_version: Optional[TLSVersion] = ..., ciphers: Optional[str] = ...) -> None:
        ...
    
    def get(self) -> SSLContext:
        ...
    


class UnixDomainSocketConnection(AbstractConnection):
    "Manages UDS communication to and from a Redis server"
    def __init__(self, *, path: str = ..., **kwargs) -> None:
        ...
    
    def repr_pieces(self) -> Iterable[Tuple[str, Union[str, int]]]:
        ...
    


FALSE_STRINGS = ...
def to_bool(value) -> Optional[bool]:
    ...

URL_QUERY_ARGUMENT_PARSERS: Mapping[str, Callable[..., object]] = ...
class ConnectKwargs(TypedDict, total=False):
    username: str
    password: str
    connection_class: Type[AbstractConnection]
    host: str
    port: int
    db: int
    path: str
    ...


def parse_url(url: str) -> ConnectKwargs:
    ...

_CP = TypeVar("_CP", bound="ConnectionPool")
class ConnectionPool:
    """
    Create a connection pool. ``If max_connections`` is set, then this
    object raises :py:class:`~redis.ConnectionError` when the pool's
    limit is reached.

    By default, TCP connections are created unless ``connection_class``
    is specified. Use :py:class:`~redis.UnixDomainSocketConnection` for
    unix sockets.
    :py:class:`~redis.SSLConnection` can be used for SSL enabled connections.

    Any additional keyword arguments are passed to the constructor of
    ``connection_class``.
    """
    @classmethod
    def from_url(cls: Type[_CP], url: str, **kwargs) -> _CP:
        """
        Return a connection pool configured from the given URL.

        For example::

            redis://[[username]:[password]]@localhost:6379/0
            rediss://[[username]:[password]]@localhost:6379/0
            unix://[username@]/path/to/socket.sock?db=0[&password=password]

        Three URL schemes are supported:

        - `redis://` creates a TCP socket connection. See more at:
          <https://www.iana.org/assignments/uri-schemes/prov/redis>
        - `rediss://` creates a SSL wrapped TCP socket connection. See more at:
          <https://www.iana.org/assignments/uri-schemes/prov/rediss>
        - ``unix://``: creates a Unix Domain Socket connection.

        The username, password, hostname, path and all querystring values
        are passed through urllib.parse.unquote in order to replace any
        percent-encoded values with their corresponding characters.

        There are several ways to specify a database number. The first value
        found will be used:

        1. A ``db`` querystring option, e.g. redis://localhost?db=0

        2. If using the redis:// or rediss:// schemes, the path argument
               of the url, e.g. redis://localhost/0

        3. A ``db`` keyword argument to this function.

        If none of these options are specified, the default db=0 is used.

        All querystring options are cast to their appropriate Python types.
        Boolean arguments can be specified with string values "True"/"False"
        or "Yes"/"No". Values that cannot be properly cast cause a
        ``ValueError`` to be raised. Once parsed, the querystring arguments
        and keyword arguments are passed to the ``ConnectionPool``'s
        class initializer. In the case of conflicting arguments, querystring
        arguments always win.
        """
        ...
    
    def __init__(self, connection_class: Type[AbstractConnection] = ..., max_connections: Optional[int] = ..., **connection_kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def reset(self): # -> None:
        ...
    
    def can_get_connection(self) -> bool:
        """Return True if a connection can be retrieved from the pool."""
        ...
    
    @deprecated_args(args_to_warn=["*"], reason="Use get_connection() without args instead", version="5.3.0")
    async def get_connection(self, command_name=..., *keys, **options): # -> AbstractConnection:
        ...
    
    def get_available_connection(self): # -> AbstractConnection:
        """Get a connection from the pool, without making sure it is connected"""
        ...
    
    def get_encoder(self):
        """Return an encoder based on encoding settings"""
        ...
    
    def make_connection(self): # -> AbstractConnection:
        """Create a new connection.  Can be overridden by child classes."""
        ...
    
    async def ensure_connection(self, connection: AbstractConnection): # -> None:
        """Ensure that the connection object is connected and valid"""
        ...
    
    async def release(self, connection: AbstractConnection): # -> None:
        """Releases the connection back to the pool"""
        ...
    
    async def disconnect(self, inuse_connections: bool = ...): # -> None:
        """
        Disconnects connections in the pool

        If ``inuse_connections`` is True, disconnect connections that are
        current in use, potentially by other tasks. Otherwise only disconnect
        connections that are idle in the pool.
        """
        ...
    
    async def aclose(self) -> None:
        """Close the pool, disconnecting all connections"""
        ...
    
    def set_retry(self, retry: Retry) -> None:
        ...
    
    async def re_auth_callback(self, token: TokenInterface): # -> None:
        ...
    


class BlockingConnectionPool(ConnectionPool):
    """
    A blocking connection pool::

        >>> from redis.asyncio import Redis, BlockingConnectionPool
        >>> client = Redis.from_pool(BlockingConnectionPool())

    It performs the same function as the default
    :py:class:`~redis.asyncio.ConnectionPool` implementation, in that,
    it maintains a pool of reusable connections that can be shared by
    multiple async redis clients.

    The difference is that, in the event that a client tries to get a
    connection from the pool when all of connections are in use, rather than
    raising a :py:class:`~redis.ConnectionError` (as the default
    :py:class:`~redis.asyncio.ConnectionPool` implementation does), it
    blocks the current `Task` for a specified number of seconds until
    a connection becomes available.

    Use ``max_connections`` to increase / decrease the pool size::

        >>> pool = BlockingConnectionPool(max_connections=10)

    Use ``timeout`` to tell it either how many seconds to wait for a connection
    to become available, or to block forever:

        >>> # Block forever.
        >>> pool = BlockingConnectionPool(timeout=None)

        >>> # Raise a ``ConnectionError`` after five seconds if a connection is
        >>> # not available.
        >>> pool = BlockingConnectionPool(timeout=5)
    """
    def __init__(self, max_connections: int = ..., timeout: Optional[int] = ..., connection_class: Type[AbstractConnection] = ..., queue_class: Type[asyncio.Queue] = ..., **connection_kwargs) -> None:
        ...
    
    @deprecated_args(args_to_warn=["*"], reason="Use get_connection() without args instead", version="5.3.0")
    async def get_connection(self, command_name=..., *keys, **options): # -> AbstractConnection:
        """Gets a connection from the pool, blocking until one is available"""
        ...
    
    async def release(self, connection: AbstractConnection): # -> None:
        """Releases the connection back to the pool."""
        ...
    


