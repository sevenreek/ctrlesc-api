"""
This type stub file was generated by pyright.
"""

import threading
import ssl
from abc import abstractmethod
from typing import Any, Callable, Dict, List, Optional, Type, TypeVar, Union
from redis.cache import CacheFactoryInterface, CacheInterface
from ._parsers import Encoder, _HiredisParser, _RESP2Parser, _RESP3Parser
from .auth.token import TokenInterface
from .credentials import CredentialProvider
from .event import EventDispatcher
from .retry import Retry
from .utils import HIREDIS_AVAILABLE, SSL_AVAILABLE, deprecated_args

if SSL_AVAILABLE:
    ...
else:
    ssl = ...
if HIREDIS_AVAILABLE:
    ...
SYM_STAR = ...
SYM_DOLLAR = ...
SYM_CRLF = ...
SYM_EMPTY = ...
DEFAULT_RESP_VERSION = ...
SENTINEL = ...
DefaultParser: Type[Union[_RESP2Parser, _RESP3Parser, _HiredisParser]]
if HIREDIS_AVAILABLE:
    DefaultParser = ...
else:
    DefaultParser = ...
class HiredisRespSerializer:
    def pack(self, *args: List): # -> list[Any]:
        """Pack a series of arguments into the Redis protocol"""
        ...
    


class PythonRespSerializer:
    def __init__(self, buffer_cutoff, encode) -> None:
        ...
    
    def pack(self, *args): # -> list[Any]:
        """Pack a series of arguments into the Redis protocol"""
        ...
    


class ConnectionInterface:
    @abstractmethod
    def repr_pieces(self): # -> None:
        ...
    
    @abstractmethod
    def register_connect_callback(self, callback): # -> None:
        ...
    
    @abstractmethod
    def deregister_connect_callback(self, callback): # -> None:
        ...
    
    @abstractmethod
    def set_parser(self, parser_class): # -> None:
        ...
    
    @abstractmethod
    def get_protocol(self): # -> None:
        ...
    
    @abstractmethod
    def connect(self): # -> None:
        ...
    
    @abstractmethod
    def on_connect(self): # -> None:
        ...
    
    @abstractmethod
    def disconnect(self, *args): # -> None:
        ...
    
    @abstractmethod
    def check_health(self): # -> None:
        ...
    
    @abstractmethod
    def send_packed_command(self, command, check_health=...): # -> None:
        ...
    
    @abstractmethod
    def send_command(self, *args, **kwargs): # -> None:
        ...
    
    @abstractmethod
    def can_read(self, timeout=...): # -> None:
        ...
    
    @abstractmethod
    def read_response(self, disable_decoding=..., *, disconnect_on_error=..., push_request=...): # -> None:
        ...
    
    @abstractmethod
    def pack_command(self, *args): # -> None:
        ...
    
    @abstractmethod
    def pack_commands(self, commands): # -> None:
        ...
    
    @property
    @abstractmethod
    def handshake_metadata(self) -> Union[Dict[bytes, bytes], Dict[str, str]]:
        ...
    
    @abstractmethod
    def set_re_auth_token(self, token: TokenInterface): # -> None:
        ...
    
    @abstractmethod
    def re_auth(self): # -> None:
        ...
    


class AbstractConnection(ConnectionInterface):
    "Manages communication to and from a Redis server"
    def __init__(self, db: int = ..., password: Optional[str] = ..., socket_timeout: Optional[float] = ..., socket_connect_timeout: Optional[float] = ..., retry_on_timeout: bool = ..., retry_on_error=..., encoding: str = ..., encoding_errors: str = ..., decode_responses: bool = ..., parser_class=..., socket_read_size: int = ..., health_check_interval: int = ..., client_name: Optional[str] = ..., lib_name: Optional[str] = ..., lib_version: Optional[str] = ..., username: Optional[str] = ..., retry: Union[Any, None] = ..., redis_connect_func: Optional[Callable[[], None]] = ..., credential_provider: Optional[CredentialProvider] = ..., protocol: Optional[int] = ..., command_packer: Optional[Callable[[], None]] = ..., event_dispatcher: Optional[EventDispatcher] = ...) -> None:
        """
        Initialize a new Connection.
        To specify a retry policy for specific errors, first set
        `retry_on_error` to a list of the error/s to retry on, then set
        `retry` to a valid `Retry` object.
        To retry on TimeoutError, `retry_on_timeout` can also be set to `True`.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @abstractmethod
    def repr_pieces(self): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def register_connect_callback(self, callback): # -> None:
        """
        Register a callback to be called when the connection is established either
        initially or reconnected.  This allows listeners to issue commands that
        are ephemeral to the connection, for example pub/sub subscription or
        key tracking.  The callback must be a _method_ and will be kept as
        a weak reference.
        """
        ...
    
    def deregister_connect_callback(self, callback): # -> None:
        """
        De-register a previously registered callback.  It will no-longer receive
        notifications on connection events.  Calling this is not required when the
        listener goes away, since the callbacks are kept as weak methods.
        """
        ...
    
    def set_parser(self, parser_class): # -> None:
        """
        Creates a new instance of parser_class with socket size:
        _socket_read_size and assigns it to the parser for the connection
        :param parser_class: The required parser class
        """
        ...
    
    def connect(self): # -> None:
        "Connects to the Redis server if not already connected"
        ...
    
    def connect_check_health(self, check_health: bool = ..., retry_socket_connect: bool = ...): # -> None:
        ...
    
    def on_connect(self): # -> None:
        ...
    
    def on_connect_check_health(self, check_health: bool = ...): # -> None:
        "Initialize the connection, authenticate and select a database"
        ...
    
    def disconnect(self, *args): # -> None:
        "Disconnects from the Redis server"
        ...
    
    def check_health(self): # -> None:
        """Check the health of the connection with a PING/PONG"""
        ...
    
    def send_packed_command(self, command, check_health=...): # -> None:
        """Send an already packed command to the Redis server"""
        ...
    
    def send_command(self, *args, **kwargs): # -> None:
        """Pack and send a command to the Redis server"""
        ...
    
    def can_read(self, timeout=...):
        """Poll the socket to see if there's data that can be read."""
        ...
    
    def read_response(self, disable_decoding=..., *, disconnect_on_error=..., push_request=...):
        """Read the response from a previously sent command"""
        ...
    
    def pack_command(self, *args): # -> list[Any]:
        """Pack a series of arguments into the Redis protocol"""
        ...
    
    def pack_commands(self, commands): # -> list[Any]:
        """Pack multiple commands into the Redis protocol"""
        ...
    
    def get_protocol(self) -> Union[int, str]:
        ...
    
    @property
    def handshake_metadata(self) -> Union[Dict[bytes, bytes], Dict[str, str]]:
        ...
    
    @handshake_metadata.setter
    def handshake_metadata(self, value: Union[Dict[bytes, bytes], Dict[str, str]]): # -> None:
        ...
    
    def set_re_auth_token(self, token: TokenInterface): # -> None:
        ...
    
    def re_auth(self): # -> None:
        ...
    


class Connection(AbstractConnection):
    "Manages TCP communication to and from a Redis server"
    def __init__(self, host=..., port=..., socket_keepalive=..., socket_keepalive_options=..., socket_type=..., **kwargs) -> None:
        ...
    
    def repr_pieces(self): # -> list[Any]:
        ...
    


class CacheProxyConnection(ConnectionInterface):
    DUMMY_CACHE_VALUE = ...
    MIN_ALLOWED_VERSION = ...
    DEFAULT_SERVER_NAME = ...
    def __init__(self, conn: ConnectionInterface, cache: CacheInterface, pool_lock: threading.RLock) -> None:
        ...
    
    def repr_pieces(self): # -> None:
        ...
    
    def register_connect_callback(self, callback): # -> None:
        ...
    
    def deregister_connect_callback(self, callback): # -> None:
        ...
    
    def set_parser(self, parser_class): # -> None:
        ...
    
    def connect(self): # -> None:
        ...
    
    def on_connect(self): # -> None:
        ...
    
    def disconnect(self, *args): # -> None:
        ...
    
    def check_health(self): # -> None:
        ...
    
    def send_packed_command(self, command, check_health=...): # -> None:
        ...
    
    def send_command(self, *args, **kwargs): # -> None:
        ...
    
    def can_read(self, timeout=...): # -> None:
        ...
    
    def read_response(self, disable_decoding=..., *, disconnect_on_error=..., push_request=...): # -> bytes | None:
        ...
    
    def pack_command(self, *args): # -> None:
        ...
    
    def pack_commands(self, commands): # -> None:
        ...
    
    @property
    def handshake_metadata(self) -> Union[Dict[bytes, bytes], Dict[str, str]]:
        ...
    
    def get_protocol(self): # -> None:
        ...
    
    def set_re_auth_token(self, token: TokenInterface): # -> None:
        ...
    
    def re_auth(self): # -> None:
        ...
    


class SSLConnection(Connection):
    """Manages SSL connections to and from the Redis server(s).
    This class extends the Connection class, adding SSL functionality, and making
    use of ssl.SSLContext (https://docs.python.org/3/library/ssl.html#ssl.SSLContext)
    """
    def __init__(self, ssl_keyfile=..., ssl_certfile=..., ssl_cert_reqs=..., ssl_ca_certs=..., ssl_ca_data=..., ssl_check_hostname=..., ssl_ca_path=..., ssl_password=..., ssl_validate_ocsp=..., ssl_validate_ocsp_stapled=..., ssl_ocsp_context=..., ssl_ocsp_expected_cert=..., ssl_min_version=..., ssl_ciphers=..., **kwargs) -> None:
        """Constructor

        Args:
            ssl_keyfile: Path to an ssl private key. Defaults to None.
            ssl_certfile: Path to an ssl certificate. Defaults to None.
            ssl_cert_reqs: The string value for the SSLContext.verify_mode (none, optional, required), or an ssl.VerifyMode. Defaults to "required".
            ssl_ca_certs: The path to a file of concatenated CA certificates in PEM format. Defaults to None.
            ssl_ca_data: Either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates.
            ssl_check_hostname: If set, match the hostname during the SSL handshake. Defaults to False.
            ssl_ca_path: The path to a directory containing several CA certificates in PEM format. Defaults to None.
            ssl_password: Password for unlocking an encrypted private key. Defaults to None.

            ssl_validate_ocsp: If set, perform a full ocsp validation (i.e not a stapled verification)
            ssl_validate_ocsp_stapled: If set, perform a validation on a stapled ocsp response
            ssl_ocsp_context: A fully initialized OpenSSL.SSL.Context object to be used in verifying the ssl_ocsp_expected_cert
            ssl_ocsp_expected_cert: A PEM armoured string containing the expected certificate to be returned from the ocsp verification service.
            ssl_min_version: The lowest supported SSL version. It affects the supported SSL versions of the SSLContext. None leaves the default provided by ssl module.
            ssl_ciphers: A string listing the ciphers that are allowed to be used. Defaults to None, which means that the default ciphers are used. See https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_ciphers for more information.

        Raises:
            RedisError
        """
        ...
    


class UnixDomainSocketConnection(AbstractConnection):
    "Manages UDS communication to and from a Redis server"
    def __init__(self, path=..., socket_timeout=..., **kwargs) -> None:
        ...
    
    def repr_pieces(self): # -> list[Any]:
        ...
    


FALSE_STRINGS = ...
def to_bool(value): # -> bool | None:
    ...

URL_QUERY_ARGUMENT_PARSERS = ...
def parse_url(url): # -> dict[Any, Any]:
    ...

_CP = TypeVar("_CP", bound="ConnectionPool")
class ConnectionPool:
    """
    Create a connection pool. ``If max_connections`` is set, then this
    object raises :py:class:`~redis.exceptions.ConnectionError` when the pool's
    limit is reached.

    By default, TCP connections are created unless ``connection_class``
    is specified. Use class:`.UnixDomainSocketConnection` for
    unix sockets.
    :py:class:`~redis.SSLConnection` can be used for SSL enabled connections.

    Any additional keyword arguments are passed to the constructor of
    ``connection_class``.
    """
    @classmethod
    def from_url(cls: Type[_CP], url: str, **kwargs) -> _CP:
        """
        Return a connection pool configured from the given URL.

        For example::

            redis://[[username]:[password]]@localhost:6379/0
            rediss://[[username]:[password]]@localhost:6379/0
            unix://[username@]/path/to/socket.sock?db=0[&password=password]

        Three URL schemes are supported:

        - `redis://` creates a TCP socket connection. See more at:
          <https://www.iana.org/assignments/uri-schemes/prov/redis>
        - `rediss://` creates a SSL wrapped TCP socket connection. See more at:
          <https://www.iana.org/assignments/uri-schemes/prov/rediss>
        - ``unix://``: creates a Unix Domain Socket connection.

        The username, password, hostname, path and all querystring values
        are passed through urllib.parse.unquote in order to replace any
        percent-encoded values with their corresponding characters.

        There are several ways to specify a database number. The first value
        found will be used:

            1. A ``db`` querystring option, e.g. redis://localhost?db=0
            2. If using the redis:// or rediss:// schemes, the path argument
               of the url, e.g. redis://localhost/0
            3. A ``db`` keyword argument to this function.

        If none of these options are specified, the default db=0 is used.

        All querystring options are cast to their appropriate Python types.
        Boolean arguments can be specified with string values "True"/"False"
        or "Yes"/"No". Values that cannot be properly cast cause a
        ``ValueError`` to be raised. Once parsed, the querystring arguments
        and keyword arguments are passed to the ``ConnectionPool``'s
        class initializer. In the case of conflicting arguments, querystring
        arguments always win.
        """
        ...
    
    def __init__(self, connection_class=..., max_connections: Optional[int] = ..., cache_factory: Optional[CacheFactoryInterface] = ..., **connection_kwargs) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def get_protocol(self): # -> None:
        """
        Returns:
            The RESP protocol version, or ``None`` if the protocol is not specified,
            in which case the server default will be used.
        """
        ...
    
    def reset(self) -> None:
        ...
    
    @deprecated_args(args_to_warn=["*"], reason="Use get_connection() without args instead", version="5.3.0")
    def get_connection(self, command_name=..., *keys, **options) -> Connection:
        "Get a connection from the pool"
        ...
    
    def get_encoder(self) -> Encoder:
        "Return an encoder based on encoding settings"
        ...
    
    def make_connection(self) -> ConnectionInterface:
        "Create a new connection"
        ...
    
    def release(self, connection: Connection) -> None:
        "Releases the connection back to the pool"
        ...
    
    def owns_connection(self, connection: Connection) -> int:
        ...
    
    def disconnect(self, inuse_connections: bool = ...) -> None:
        """
        Disconnects connections in the pool

        If ``inuse_connections`` is True, disconnect connections that are
        current in use, potentially by other threads. Otherwise only disconnect
        connections that are idle in the pool.
        """
        ...
    
    def close(self) -> None:
        """Close the pool, disconnecting all connections"""
        ...
    
    def set_retry(self, retry: Retry) -> None:
        ...
    
    def re_auth_callback(self, token: TokenInterface): # -> None:
        ...
    


class BlockingConnectionPool(ConnectionPool):
    """
    Thread-safe blocking connection pool::

        >>> from redis.client import Redis
        >>> client = Redis(connection_pool=BlockingConnectionPool())

    It performs the same function as the default
    :py:class:`~redis.ConnectionPool` implementation, in that,
    it maintains a pool of reusable connections that can be shared by
    multiple redis clients (safely across threads if required).

    The difference is that, in the event that a client tries to get a
    connection from the pool when all of connections are in use, rather than
    raising a :py:class:`~redis.ConnectionError` (as the default
    :py:class:`~redis.ConnectionPool` implementation does), it
    makes the client wait ("blocks") for a specified number of seconds until
    a connection becomes available.

    Use ``max_connections`` to increase / decrease the pool size::

        >>> pool = BlockingConnectionPool(max_connections=10)

    Use ``timeout`` to tell it either how many seconds to wait for a connection
    to become available, or to block forever:

        >>> # Block forever.
        >>> pool = BlockingConnectionPool(timeout=None)

        >>> # Raise a ``ConnectionError`` after five seconds if a connection is
        >>> # not available.
        >>> pool = BlockingConnectionPool(timeout=5)
    """
    def __init__(self, max_connections=..., timeout=..., connection_class=..., queue_class=..., **connection_kwargs) -> None:
        ...
    
    def reset(self): # -> None:
        ...
    
    def make_connection(self): # -> CacheProxyConnection | Connection:
        "Make a fresh connection."
        ...
    
    @deprecated_args(args_to_warn=["*"], reason="Use get_connection() without args instead", version="5.3.0")
    def get_connection(self, command_name=..., *keys, **options): # -> CacheProxyConnection | Connection:
        """
        Get a connection, blocking for ``self.timeout`` until a connection
        is available from the pool.

        If the connection returned is ``None`` then creates a new connection.
        Because we use a last-in first-out queue, the existing connections
        (having been returned to the pool after the initial ``None`` values
        were added) will be returned before ``None`` values. This means we only
        create new connections when we need to, i.e.: the actual number of
        connections will only increase in response to demand.
        """
        ...
    
    def release(self, connection): # -> None:
        "Releases the connection back to the pool."
        ...
    
    def disconnect(self): # -> None:
        "Disconnects all connections in the pool."
        ...
    


