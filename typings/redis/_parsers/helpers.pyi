"""
This type stub file was generated by pyright.
"""

def timestamp_to_datetime(response): # -> datetime | None:
    "Converts a unix timestamp to a Python datetime object"
    ...

def parse_debug_object(response): # -> dict[str, str]:
    "Parse the results of Redis's DEBUG OBJECT command into a Python dict"
    ...

def parse_info(response): # -> dict[Any, Any]:
    """Parse the result of Redis's INFO command into a Python dict"""
    ...

def parse_memory_stats(response, **kwargs): # -> dict[Any, Any] | dict[str, str]:
    """Parse the results of MEMORY STATS"""
    ...

SENTINEL_STATE_TYPES = ...
def parse_sentinel_state(item): # -> dict[Any, Any]:
    ...

def parse_sentinel_master(response): # -> dict[Any, Any]:
    ...

def parse_sentinel_state_resp3(response): # -> dict[Any, Any]:
    ...

def parse_sentinel_masters(response): # -> dict[Any, Any]:
    ...

def parse_sentinel_masters_resp3(response): # -> list[dict[Any, Any]]:
    ...

def parse_sentinel_slaves_and_sentinels(response): # -> list[dict[Any, Any]]:
    ...

def parse_sentinel_slaves_and_sentinels_resp3(response): # -> list[dict[Any, Any]]:
    ...

def parse_sentinel_get_master(response): # -> tuple[Any, int] | None:
    ...

def pairs_to_dict(response, decode_keys=..., decode_string_values=...): # -> dict[Any, Any] | dict[str, str]:
    """Create a dict given a list of key/value pairs"""
    ...

def pairs_to_dict_typed(response, type_info): # -> dict[Any, Any]:
    ...

def zset_score_pairs(response, **options): # -> list[tuple[Any, Any]]:
    """
    If ``withscores`` is specified in the options, return the response as
    a list of (value, score) pairs
    """
    ...

def sort_return_tuples(response, **options): # -> list[tuple[Any, ...]]:
    """
    If ``groups`` is specified, return the response as a list of
    n-element tuples with n being the value found in options['groups']
    """
    ...

def parse_stream_list(response): # -> list[Any] | None:
    ...

def pairs_to_dict_with_str_keys(response): # -> dict[Any, Any] | dict[str, str]:
    ...

def parse_list_of_dicts(response): # -> list[dict[Any, Any] | dict[str, str]]:
    ...

def parse_xclaim(response, **options): # -> list[Any] | None:
    ...

def parse_xautoclaim(response, **options):
    ...

def parse_xinfo_stream(response, **options): # -> dict[Any, Any] | dict[str, str] | dict[str, Any]:
    ...

def parse_xread(response): # -> list[Any] | list[list[Any]]:
    ...

def parse_xread_resp3(response): # -> dict[Any, Any] | dict[Any, list[list[Any] | None]]:
    ...

def parse_xpending(response, **options): # -> list[dict[Literal['message_id', 'consumer', 'time_since_delivered', 'times_delivered'], Any]] | dict[str, Any]:
    ...

def parse_xpending_range(response): # -> list[dict[Literal['message_id', 'consumer', 'time_since_delivered', 'times_delivered'], Any]]:
    ...

def float_or_none(response): # -> float | None:
    ...

def bool_ok(response, **options): # -> bool:
    ...

def parse_zadd(response, **options): # -> float | int | None:
    ...

def parse_client_list(response, **options): # -> list[Any]:
    ...

def parse_config_get(response, **options): # -> list[str | None] | dict[str, str] | dict[Any, Any]:
    ...

def parse_scan(response, **options): # -> tuple[int, Any]:
    ...

def parse_hscan(response, **options): # -> tuple[int, Any | dict[str, str] | dict[Any, Any] | list[Any]]:
    ...

def parse_zscan(response, **options): # -> tuple[int, list[tuple[Any, Any]]]:
    ...

def parse_zmscore(response, **options): # -> list[float | None]:
    ...

def parse_slowlog_get(response, **options): # -> list[dict[str, Any]]:
    ...

def parse_stralgo(response, **options): # -> int | dict[str, Any] | str:
    """
    Parse the response from `STRALGO` command.
    Without modifiers the returned value is string.
    When LEN is given the command returns the length of the result
    (i.e integer).
    When IDX is given the command returns a dictionary with the LCS
    length and all the ranges in both the strings, start and end
    offset for each string, where there are matches.
    When WITHMATCHLEN is given, each array representing a match will
    also have the length of the match at the beginning of the array.
    """
    ...

def parse_cluster_info(response, **options): # -> dict[str, str]:
    ...

def parse_cluster_nodes(response, **options): # -> dict[Any, dict[str, Any]]:
    """
    @see: https://redis.io/commands/cluster-nodes  # string / bytes
    @see: https://redis.io/commands/cluster-replicas # list of string / bytes
    """
    ...

def parse_geosearch_generic(response, **options): # -> list[Any] | list[list[Any]]:
    """
    Parse the response of 'GEOSEARCH', GEORADIUS' and 'GEORADIUSBYMEMBER'
    commands according to 'withdist', 'withhash' and 'withcoord' labels.
    """
    ...

def parse_command(response, **options): # -> dict[Any, Any]:
    ...

def parse_command_resp3(response, **options): # -> dict[Any, Any]:
    ...

def parse_pubsub_numsub(response, **options): # -> list[tuple[Any, Any]]:
    ...

def parse_client_kill(response, **options): # -> int | bool:
    ...

def parse_acl_getuser(response, **options): # -> dict[Any, Any] | dict[str, str] | dict[str, Any] | None:
    ...

def parse_acl_log(response, **options): # -> bool | list[Any] | None:
    ...

def parse_client_info(value): # -> dict[Any, Any]:
    """
    Parsing client-info in ACL Log in following format.
    "key1=value1 key2=value2 key3=value3"
    """
    ...

def parse_set_result(response, **options): # -> bool:
    """
    Handle SET result since GET argument is available since Redis 6.2.
    Parsing SET result into:
    - BOOL
    - String when GET argument is used
    """
    ...

def string_keys_to_dict(key_string, callback): # -> dict[Any, Any | None]:
    ...

_RedisCallbacks = ...
_RedisCallbacksRESP2 = ...
_RedisCallbacksRESP3 = ...
